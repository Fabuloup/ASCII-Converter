<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <title>ASCII Converter</title>
</head>

<body>
    <style>
        :root {
            font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: #111;
            color: #eee
        }

        h1 {
            margin: 6px 0 14px
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 12px
        }

        .drop {
            width: 480px;
            max-width: 90vw;
            padding: 18px;
            border: 2px dashed #444;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent)
        }

        .drop.dragover {
            border-color: #66f
        }

        .meta {
            font-size: 13px;
            color: #bfbfbf;
            margin-top: 6px
        }

        canvas {
            background: #000;
            border-radius: 4px;
            max-width: 100%
        }

        label {
            font-size: 14px
        }

        input[type=range] {
            width: 180px
        }

        .right {
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center
        }
    </style>

    <h1>ASCII Image Converter</h1>

    <div class="controls">
        <div>
            <input id="fileInput" type="file" accept="image/*">
            <div id="drop" class="drop">Drop image here or click to select</div>
            <div id="info" class="meta">No image loaded</div>
            <div style="margin-top:8px;display:flex;gap:8px">
                <button id="downloadPng" type="button">Download PNG</button>
                <button id="downloadTxt" type="button">Download TXT</button>
            </div>
        </div>

        <div class="right">
            <div class="row"><label for="cols">Columns</label><input id="cols" type="range" min="20" max="200"
                    value="100"><span id="colsVal">100</span></div>
            <div class="row"><label for="brightness">Brightness</label><input id="brightness" type="range" min="-100"
                    max="100" value="0"><span id="brightnessVal">0</span></div>
            <div class="row"><label for="contrast">Contrast</label><input id="contrast" type="range" min="0" max="200"
                    value="100"><span id="contrastVal">100</span></div>
            <div class="row"><label><input id="invert" type="checkbox"> Invert</label></div>
            <div class="row"><label for="mode">Mode</label>
                <select id="mode">
                    <option value="ascii">ASCII</option>
                    <option value="outline">Outline</option>
                    <option value="both">Both</option>
                </select>
            </div>
            <div class="row" style="flex-direction:column;align-items:flex-start">
                <label for="charset">Charset</label>
                <input id="charset" type="text" style="width:220px" title="Type characters from light to dark">
                <div style="display:flex;gap:6px;margin-top:6px;flex-wrap:wrap">
                    <button id="preset1" type="button"> .,:;+*?%S#░▒@▓█</button>
                    <button id="preset2" type="button"> .,:;+*?%S#@</button>
                    <button id="preset3" type="button"> `~p0N&░▒▓█</button>
                    <button id="preset4" type="button"> ░▒▓█</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id="asciiCanvas"></canvas>
    <!-- hidden canvas used for pixel sampling -->
    <canvas id="sampleCanvas" style="display:none"></canvas>
    <canvas id="sampleOutlineCanvas" style="display:none"></canvas>

    <script>
        (function () {
            const fileInput = document.getElementById('fileInput');
            const drop = document.getElementById('drop');
            const info = document.getElementById('info');
            const colsRange = document.getElementById('cols');
            const colsVal = document.getElementById('colsVal');
            const brightnessRange = document.getElementById('brightness');
            const brightnessVal = document.getElementById('brightnessVal');
            const contrastRange = document.getElementById('contrast');
            const contrastVal = document.getElementById('contrastVal');
            const invertChk = document.getElementById('invert');
            const asciiCanvas = document.getElementById('asciiCanvas');
            const sampleCanvas = document.getElementById('sampleCanvas');
            const sampleOutlineCanvas = document.getElementById('sampleOutlineCanvas');

            const asciiCtx = asciiCanvas.getContext('2d');
            const sampleCtx = sampleCanvas.getContext('2d');
            const sampleOutlineCtx = sampleOutlineCanvas.getContext('2d');

            // Charset input and presets
            const charsetInput = document.getElementById('charset');
            const preset1 = document.getElementById('preset1');
            const preset2 = document.getElementById('preset2');
            const preset3 = document.getElementById('preset3');
            const preset4 = document.getElementById('preset4');
            const modeSelect = document.getElementById('mode');
            const downloadPngBtn = document.getElementById('downloadPng');
            const downloadTxtBtn = document.getElementById('downloadTxt');

            // last rendered ASCII text (kept in sync during render)
            let lastAsciiText = '';

            // Default charset (light to dark)
            const defaultCharset = ' .,:;+*?%S#░▒@▓█';

            // initialize charset input
            charsetInput.value = defaultCharset;

            let img = null;

            function prevent(e) { e.preventDefault(); e.stopPropagation(); }

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => drop.addEventListener(evt, prevent));

            drop.addEventListener('dragover', () => drop.classList.add('dragover'));
            drop.addEventListener('dragleave', () => drop.classList.remove('dragover'));
            drop.addEventListener('drop', (e) => {
                drop.classList.remove('dragover');
                const f = e.dataTransfer.files && e.dataTransfer.files[0];
                if (f) handleFile(f);
            });

            drop.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', () => {
                const f = fileInput.files && fileInput.files[0];
                if (f) handleFile(f);
            });

            colsRange.addEventListener('input', () => { colsVal.textContent = colsRange.value; if (img) render(); });
            brightnessRange.addEventListener('input', () => { brightnessVal.textContent = brightnessRange.value; if (img) render(); });
            contrastRange.addEventListener('input', () => { contrastVal.textContent = contrastRange.value; if (img) render(); });
            invertChk.addEventListener('change', () => { if (img) render(); });
            // charset input and presets
            charsetInput.addEventListener('input', () => { if (img) render(); });
            preset1.addEventListener('click', () => { charsetInput.value = preset1.textContent; if (img) render(); });
            preset2.addEventListener('click', () => { charsetInput.value = preset2.textContent; if (img) render(); });
            preset3.addEventListener('click', () => { charsetInput.value = preset3.textContent; if (img) render(); });
            preset4.addEventListener('click', () => { charsetInput.value = preset4.textContent; if (img) render(); });
            modeSelect.addEventListener('change', () => { if (img) render(); });

            function handleFile(file) {
                if (!file.type.startsWith('image/')) { info.textContent = 'Please drop an image file'; return; }
                const reader = new FileReader();
                reader.onload = () => {
                    const i = new Image();
                    i.onload = () => { img = i; info.textContent = `${file.name} — ${i.width}×${i.height}`; render(); };
                    i.src = reader.result;
                };
                reader.readAsDataURL(file);
            }

            // Render image to ascii canvas
            function render() {
                if (!img) return;

                const targetCols = parseInt(colsRange.value, 10) || 100;

                // build ascii chars array from input (preserve order)
                const asciiChars = (charsetInput.value && charsetInput.value.length > 0 ? charsetInput.value : defaultCharset).split('');

                const mode = modeSelect.value; // 'ascii' | 'outline' | 'both'

                // Character cell aspect ratio correction (characters are taller than wide)
                const charWidth = 6; // will be set later with font
                const charHeight = 11; // approximate
                //const aspect = charHeight / charWidth; // ~1.6
                const aspect = 1;

                const sampleW = targetCols;
                const sampleH = Math.max(1, Math.round((img.height / img.width) * sampleW * aspect * 0.55));

                // If outline or both, compute outline map on a higher-resolution sample
                let outlineMap = null; // will be a 2D array of same size as ascii grid containing ' ', '/', '\\', '|', '⏤'
                if (mode === 'outline' || mode === 'both') {
                    // sample at twice the width for better edge detection
                    const outlineW = sampleW * 2;
                    const outlineH = sampleH * 2;
                    sampleOutlineCanvas.width = outlineW;
                    sampleOutlineCanvas.height = outlineH;
                    sampleOutlineCtx.clearRect(0, 0, outlineW, outlineH);
                    // draw with nearest-neighbor sampling for crisp pixels
                    sampleOutlineCtx.imageSmoothingEnabled = false;
                    sampleOutlineCtx.drawImage(img, 0, 0, outlineW, outlineH);

                    const outImage = sampleOutlineCtx.getImageData(0, 0, outlineW, outlineH);
                    const outData = outImage.data;

                    // allocate outlineMap to the ascii grid size
                    outlineMap = new Array(sampleH);
                    for (let i = 0; i < sampleH; i++) outlineMap[i] = new Array(sampleW).fill(' ');


                    // Prepare brightness/contrast/invert settings to apply to outline sampling
                    const bAdjust = parseInt(brightnessRange.value, 10) / 100; // -1 .. 1
                    const cAdjust = parseInt(contrastRange.value, 10) / 100; // 0 .. 2 (1 = normal)
                    const doInvert = invertChk.checked;

                    // helper to get adjusted luminance at (sx,sy) as 0..255
                    function lumAt(sx, sy) {
                        const idx = (sy * outlineW + sx) * 4;
                        const r = outData[idx];
                        const g = outData[idx + 1];
                        const b = outData[idx + 2];
                        let lum = 0.2126 * r + 0.7152 * g + 0.0722 * b; // 0..255
                        // convert to 0..1
                        let t = lum / 255;
                        // apply contrast and brightness (same formula used later for ascii sampling)
                        t = (t - 0.5) * cAdjust + 0.5;
                        t = t + bAdjust;
                        t = Math.max(0, Math.min(1, t));
                        if (doInvert) t = 1 - t;
                        return t * 255;
                    }

                    // thresholds
                    const edgeThreshold = 20; // min grey-level difference to be considered an edge

                    // helper: sample a low-res cell (ax,ay) by reading its 2x2 pixels from the high-res outline canvas
                    // returns null if out of bounds, otherwise an object {p00,p10,p01,p11,b00,b10,b01,b11,lumMax,lumMin,binaryThr,topAvg,...}
                    function sample2x2(ax, ay, draw = false) {
                        if (ax < 0 || ay < 0 || ax >= outlineW || ay >= outlineH) return null;
                        if (ax + 1 >= outlineW || ay + 1 >= outlineH) return null;
                        const np00 = lumAt(ax, ay);
                        const np10 = lumAt(ax + 1, ay);
                        const np01 = lumAt(ax, ay + 1);
                        const np11 = lumAt(ax + 1, ay + 1);

                        const lumMax = Math.max(np00, np10, np01, np11);
                        const lumMin = Math.min(np00, np10, np01, np11);
                        const localBinaryThr = (lumMax - lumMin >= edgeThreshold) ? lumMin + edgeThreshold : 128;

                        const nb00 = np00 < localBinaryThr ? 1 : 0;
                        const nb10 = np10 < localBinaryThr ? 1 : 0;
                        const nb01 = np01 < localBinaryThr ? 1 : 0;
                        const nb11 = np11 < localBinaryThr ? 1 : 0;

                        if (draw) {
                            sampleOutlineCtx.save();
                            sampleOutlineCtx.globalCompositeOperation = 'source-over';
                            const drawPixel = (px, py, bit) => {
                                sampleOutlineCtx.fillStyle = bit ? 'rgba(0,0,0,1.0)' : 'rgba(255,255,255,1.0)';
                                sampleOutlineCtx.fillRect(px, py, 1, 1);
                            };
                            drawPixel(ax, ay, nb00);
                            drawPixel(ax + 1, ay, nb10);
                            drawPixel(ax, ay + 1, nb01);
                            drawPixel(ax + 1, ay + 1, nb11);
                            sampleOutlineCtx.restore();
                        }

                        const topAvg = (np00 + np10) / 2;
                        const bottomAvg = (np01 + np11) / 2;
                        const leftAvg = (np00 + np01) / 2;
                        const rightAvg = (np10 + np11) / 2;
                        const diffTB = Math.abs(topAvg - bottomAvg);
                        const diffLR = Math.abs(leftAvg - rightAvg);
                        const diag1Avg = (np00 + np11) / 2; // \ diagonal (TL + BR)
                        const diag2Avg = (np10 + np01) / 2; // / diagonal (TR + BL)
                        const diffDiag = Math.abs(diag1Avg - diag2Avg);

                        return {
                            p00: np00, p10: np10, p01: np01, p11: np11,
                            b00: nb00, b10: nb10, b01: nb01, b11: nb11,
                            lumMax, lumMin, binaryThr: localBinaryThr,
                            topAvg, bottomAvg, leftAvg, rightAvg, diffTB, diffLR, diag1Avg, diag2Avg, diffDiag
                        };
                    }

                    // For each cell in the low-res sample, examine the 2x2 block in the high-res outline canvas
                    for (let ay = 0; ay < sampleH; ay++) {
                        for (let ax = 0; ax < sampleW; ax++) {
                            const cell = sample2x2(ax*2, ay*2, true);
                            if (!cell) continue;

                            const { p00, p10, p01, p11, b00, b10, b01, b11, topAvg, bottomAvg, leftAvg, rightAvg, diffTB, diffLR, diag1Avg, diag2Avg, diffDiag } = cell;

                            let ch = ' ';

                            // diagonal binary patterns for '/'
                            const isSlashBinary = (
                                b10 === 1 && b10 === b01 && (b00 !== b10 || b11 !== b10)
                            );
                            // diagonal binary patterns for '\\'
                            const isBackslashBinary = (
                                b00 === 1 && b00 === b11 && (b10 !== b00 || b01 !== b00)
                            );

                            // horizontal pattern: top row different from bottom row
                            const isHorizontalBinary = (b00 === b10 && b01 === b11 && b00 !== b01);
                            // vertical pattern: left column different from right column
                            const isVerticalBinary = (b00 === b01 && b10 === b11 && b00 !== b10);

                            // Priority: explicit diagonal binary matches first, then diagonal grey check, then horizontal/vertical
                            if (isSlashBinary) {
                                ch = '/';
                            } else if (isBackslashBinary) {
                                ch = '\\';
                            } else if (diffDiag > Math.max(diffTB, diffLR) && diffDiag > edgeThreshold) {
                                // decide diagonal direction by which diagonal is darker (smaller luminance)
                                if (diag2Avg < diag1Avg) ch = '/'; else ch = '\\';
                            } else if (isHorizontalBinary || (diffTB > diffLR && diffTB > edgeThreshold)) {
                                ch = '⏤';
                            } else if (isVerticalBinary || (diffLR > diffTB && diffLR > edgeThreshold)) {
                                ch = '|';
                            } else {
                                ch = ' ';
                            }

                            // If the cell is uniformly dark (full black), try shifting +/-1 in x and y to detect nearby horizontal/vertical edges
                            const isFullDark = (b00 === 1 && b10 === 1 && b01 === 1 && b11 === 1);
                            if (ch === ' ' && isFullDark) {
                                // check neighbors in x for vertical edges
                                const left = sample2x2(ax*2 - 1, ay*2, false);
                                const right = sample2x2(ax*2 + 1, ay*2, false);
                                if (left) {
                                    const isLeftVertical = (left.b00 === left.b01 && left.b10 === left.b11 && left.b00 !== left.b10);
                                    if (isLeftVertical) ch = '|';
                                }
                                if (ch === ' ' && right) {
                                    const isRightVertical = (right.b00 === right.b01 && right.b10 === right.b11 && right.b00 !== right.b10);
                                    if (isRightVertical) ch = '|';
                                }

                                // check neighbors in y for horizontal edges
                                if (ch === ' ') {
                                    const up = sample2x2(ax*2, ay*2 - 1, false);
                                    const down = sample2x2(ax*2, ay*2 + 1, false);
                                    if (up) {
                                        const isUpHorizontal = (up.b00 === up.b10 && up.b01 === up.b11 && up.b00 !== up.b01);
                                        if (isUpHorizontal) ch = '⏤';
                                    }
                                    if (ch === ' ' && down) {
                                        const isDownHorizontal = (down.b00 === down.b10 && down.b01 === down.b11 && down.b00 !== down.b01);
                                        if (isDownHorizontal) ch = '⏤';
                                    }
                                }
                            }

                            outlineMap[ay][ax] = ch;
                        }
                    }
                }

                // Draw scaled image to sample canvas
                sampleCanvas.width = sampleW;
                sampleCanvas.height = sampleH;
                sampleCtx.clearRect(0, 0, sampleCanvas.width, sampleCanvas.height);
                // Use drawImage with nearest-neighbor sampling (disable smoothing) for crisp pixel sampling
                sampleCtx.imageSmoothingEnabled = false;
                sampleCtx.drawImage(img, 0, 0, sampleCanvas.width, sampleCanvas.height);

                const imgData = sampleCtx.getImageData(0, 0, sampleCanvas.width, sampleCanvas.height).data;

                // Prepare ascii canvas: each character cell size
                const fontSize = Math.max(24, Math.floor(Math.min(28, 600 / targetCols)));
                const cellW = Math.round(fontSize * 0.6);
                const cellH = Math.round(fontSize * 1.1);

                asciiCanvas.width = sampleCanvas.width * cellW;
                asciiCanvas.height = sampleCanvas.height * cellH;
                asciiCtx.fillStyle = '#fff';
                asciiCtx.fillRect(0, 0, asciiCanvas.width, asciiCanvas.height);
                asciiCtx.fillStyle = '#000';
                asciiCtx.font = `${fontSize}px monospace`;
                asciiCtx.textBaseline = 'top';

                const invert = invertChk.checked;

                // Map pixels to characters
                const lines = [];
                for (let y = 0; y < sampleCanvas.height; y++) {
                    let line = '';
                    for (let x = 0; x < sampleCanvas.width; x++) {
                        const idx = (y * sampleCanvas.width + x) * 4;
                        const r = imgData[idx];
                        const g = imgData[idx + 1];
                        const b = imgData[idx + 2];
                        // luminance
                        const lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;
                        let t = lum / 255;
                        // Apply contrast and brightness adjustments
                        const brightness = parseInt(brightnessRange.value, 10) / 100; // -1 .. 1
                        const contrast = parseInt(contrastRange.value, 10) / 100; // 0 .. 2 (1 = normal)
                        // contrast formula: shift to [-0.5,0.5], scale, shift back
                        t = (t - 0.5) * contrast + 0.5;
                        t = t + brightness;
                        // clamp
                        t = Math.max(0, Math.min(1, t));
                        if (invert) t = 1 - t;
                        const charIndex = Math.floor((1 - t) * (asciiChars.length - 1));
                        // choose char: if outlineMap exists and has a character for this cell use it depending on mode
                        let ch = asciiChars[charIndex];
                        if (outlineMap && outlineMap[y] && outlineMap[y][x]) {
                            if (mode === 'outline') ch = outlineMap[y][x];
                            else if (mode === 'both' && outlineMap[y][x] !== ' ') {
                                // choose outline char if edge is strong otherwise keep ascii char
                                ch = outlineMap[y][x];
                            }
                        }
                        const px = x * cellW;
                        const py = y * cellH;
                        asciiCtx.fillText(ch, px, py);
                        line += ch;
                    }
                    lines.push(line);
                }

                // store last ASCII text for download
                lastAsciiText = lines.join('\n');
            }

            // Initialize display values
            colsVal.textContent = colsRange.value;
            brightnessVal.textContent = brightnessRange.value;
            contrastVal.textContent = contrastRange.value;

            // Download button handlers
            downloadPngBtn.addEventListener('click', () => {
                // create PNG from asciiCanvas
                const url = asciiCanvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = url;
                a.download = `ascii-${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                a.remove();
            });

            downloadTxtBtn.addEventListener('click', () => {
                const txt = lastAsciiText || '';
                const blob = new Blob([txt], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ascii-${Date.now()}.txt`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            });

        })();
    </script>
</body>

</html>